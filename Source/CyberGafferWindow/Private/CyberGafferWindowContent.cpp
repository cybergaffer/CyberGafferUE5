#include "CyberGafferWindowContent.h"
#include "CyberGafferWindow.h"
#include "CyberGafferLog.h"
#include "CyberGafferWindowStyle.h"

#include "Widgets/Docking/SDockTab.h"
#include "Widgets/SBoxPanel.h"
#include "Widgets/Layout/SBorder.h"
#include "Widgets/Layout/SGridPanel.h"
#include "Widgets/Text/STextBlock.h"
#include "Widgets/Input/SNumericEntryBox.h"
#include "Widgets/Layout/SWidgetSwitcher.h"
#include "Widgets/SNullWidget.h"
#include "SWarningOrErrorBox.h"
#include "Layout/Margin.h"
#include "Styling/AppStyle.h"
#include "UObject/ConstructorHelpers.h"

#include "Materials/MaterialInstanceConstant.h"
#include "Modules/ModuleManager.h"
#include "Widgets/Colors/SColorWheel.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Editor/UnrealEd/Public/FileHelpers.h"
#include "CyberGaffer.h"
#include "Editor/LevelEditor/Public/LevelEditorActions.h"
#include "AssetToolsModule.h"
#include "CyberGafferSceneCaptureComponent2D.h"
#include "SWarningOrErrorBox.h"
#include "Factories/MaterialInstanceConstantFactoryNew.h"
#include "Dialogs/Dialogs.h"
#include "Engine/PostProcessVolume.h"

#define LOCTEXT_NAMESPACE "FCyberGafferWindowModule"

// CyberGafferWindowContent::CyberGafferWindowContent() { }
// CyberGafferWindowContent::~CyberGafferWindowContent() { }

void SCyberGafferWindowContent::Construct(const FArguments& args) {
	// Code for DetailView autogenerated UI
	// FStructureDetailsViewArgs structureDetailsViewArgs;
	// FDetailsViewArgs detailsViewArgs;
	// detailsViewArgs.bAllowSearch = false;

	
	// _windowFields = MakeShared<FStructOnScope>(FCyberGafferWindowFields::StaticStruct());
	// _detailsView = propertyEditor.CreateStructureDetailView(detailsViewArgs, structureDetailsViewArgs, _windowFields);
	// _detailsView->GetOnFinishedChangingPropertiesDelegate().AddSP(this, &SCyberGafferWindowContent::OnPropertiesChanged);

	_settings = TStrongObjectPtr<UCyberGafferWindowSettings>(NewObject<UCyberGafferWindowSettings>());

	OnSceneChanged(FString(""), false);

	// auto currentSceneSettings = _settings->GetSettingsForCurrentScene();
	// if (!currentSceneSettings.IsSet()) {
	// 	CYBERGAFFER_LOG(Error, TEXT("The current scene is not set"));
	// 	return;
	// }
	//
	// auto& propertyEditor = FModuleManager::Get().LoadModuleChecked<FPropertyEditorModule>(TEXT("PropertyEditor"));
	// FDetailsViewArgs detailsViewArgs;
	// TSharedRef<IDetailsView> detailsView = propertyEditor.CreateDetailView(detailsViewArgs);
	// detailsView->SetObject(_settings.Get());
	// detailsView->OnFinishedChangingProperties().AddSP(this, &)
	
	_containingTab = args.__containingTab;

	_currentSceneChangedDelegateHandle = FEditorDelegates::OnMapOpened.AddRaw(this, &SCyberGafferWindowContent::OnSceneChanged);
	TSharedPtr<SDockTab> tab = _containingTab.Pin();
	if (tab.IsValid()) {
		tab->SetOnTabClosed(SDockTab::FOnTabClosedCallback::CreateRaw(this, &SCyberGafferWindowContent::OnParentTabClosed));
	}
	
	auto linearPostProcessMaterialSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetLinearPostProcessMaterialPath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(UMaterialInstance::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnLinearPostProcessMaterialSelectorValueChanged));
	
	auto colorGradingPostProcessMaterialSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetColorGradingPostProcessMaterialPath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(UMaterialInstance::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnColorGradingPostProcessMaterialSelectorValueChanged));

	auto postProcessVolumeSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetPostProcessVolumePath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(APostProcessVolume::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnPostProcessVolumePathChanged));

	auto cyberGafferSceneCaptureSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetCyberGafferSceneCapturePath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(ACyberGafferSceneCapture::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnCyberGafferSceneCaptureChanged));
		
	TSharedRef<SSeparator> separator = SNew(SSeparator).Orientation(Orient_Vertical);

	const float headerWidth = 0.4f;
	const float valueWidth = 0.6f;

	const FMargin headerMargin = FMargin(5, 0, 10, 0);
	const FMargin valueMargin = FMargin(10, 0, 5, 0);
	const float verticalSlotPadding = 4.0f;
	
	FCyberGafferWindowStyle::Initialize();
	FCyberGafferWindowStyle::ReloadTextures();
	const FSlateBrush* cyberGafferLogo = FCyberGafferWindowStyle::Get().GetBrush("CyberGafferWindow.CyberGafferLogoWithText");
	
	ChildSlot [
		// Code for DetailView autogenerated UI
		// _detailsView->GetWidget().ToSharedRef()

		SNew(SScrollBox)
		.Orientation(Orient_Vertical)
		+SScrollBox::Slot()
		[
			SNew(SVerticalBox)
			+SVerticalBox::Slot()
			.AutoHeight()
			[
				SNew(SWidgetSwitcher)
				.WidgetIndex_Lambda([this]() -> int32 {
					return this->_isTempScene;
				})
				+SWidgetSwitcher::Slot()
				[
					SNullWidget::NullWidget
				]
				+SWidgetSwitcher::Slot()
				[
					SNew(SWarningOrErrorBox)
					.Padding(verticalSlotPadding)
					.MessageStyle(EMessageStyle::Warning)
					.Message(LOCTEXT("UnsavedMapText", "The current map is unsaved, please, save it, otherwise your CyberGaffer settings will be not saved"))
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SBox)
				.HAlign(HAlign_Center)
				.VAlign(VAlign_Center)
				.Padding(headerMargin)
				[
					SNew(SButton)
					.Text(LOCTEXT("NewLinearPPMIText", "New post linear process material for scene"))
					.OnClicked(this, &SCyberGafferWindowContent::CreatePostProcessMaterialInstance, PostProcessMaterialType::Linear)
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Center)
				.Padding(headerMargin)
				[
					SNew(SButton)
					.Text(LOCTEXT("NewColorGradingPPMIText", "New color grading post process material for scene"))
					.OnClicked(this, &SCyberGafferWindowContent::CreatePostProcessMaterialInstance, PostProcessMaterialType::ColorGrading)
				]
				
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("LinearPostProcessMaterialText", "Linear Post Process Material"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					linearPostProcessMaterialSelector
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("ColorGradingPostProcessMaterialText", "Color Grading Post Process Material"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					colorGradingPostProcessMaterialSelector
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("PostProcessVolumeSelectorText", "Post Process Volume"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					postProcessVolumeSelector
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("CyberGafferSceneCaptureText", "CyberGaffer Scene Capture"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					cyberGafferSceneCaptureSelector
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SSeparator)
				.Orientation(Orient_Horizontal)
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("ExposureCompensationText", "Exposure Compensation"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					SNew(SNumericEntryBox<float>)
					.Font(FAppStyle::GetFontStyle(TEXT("MenuItem.Font")))
					.AllowSpin(true)
					.MinValue(TOptional<float>())
					.MaxValue(TOptional<float>())
					.MinSliderValue(-10.0)
					.MaxSliderValue(10.0)
					.Delta(0.01f)
					.LinearDeltaSensitivity(0.001f)
					.Value(this, &SCyberGafferWindowContent::GetExposureCompensation)
					.OnValueChanged(this, &SCyberGafferWindowContent::OnExposureCompensationValueChanged)
					.OnValueCommitted(this, &SCyberGafferWindowContent::OnExposureCompensationValueCommited)
					.ToolTipText(LOCTEXT("ExposureCompensationText", "Exposure Compensation"))
					.IsEnabled(this, &SCyberGafferWindowContent::IsColorGradingPostProcessMaterialValid)
					.MinDesiredValueWidth(75.0f)
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("ColorGradingText", "Color Grading"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					SNew(SColorWheel)
					.SelectedColor(this, &SCyberGafferWindowContent::GetColorGradingColor)
					.OnValueChanged(this, &SCyberGafferWindowContent::OnColorGradingValueChanged)
					.OnMouseCaptureEnd(this, &SCyberGafferWindowContent::OnColorGradingCaptureEnd)
					.ToolTipText(LOCTEXT("ExposureCompensationText", "Exposure Compensation"))
					.IsEnabled(this, &SCyberGafferWindowContent::IsColorGradingPostProcessMaterialValid)
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("ShadersIncludePathText", "Shaders Include Path"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					SNew(SEditableTextBox)
					.Font(FAppStyle::GetFontStyle(TEXT("MenuItem.Font")))
					.Text(this, &SCyberGafferWindowContent::GetShadersIncludePath)
					.OnTextCommitted(this, &SCyberGafferWindowContent::OnShadersIncludePathCommitted)
					.MinDesiredWidth(75.0f)
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(headerWidth)
				.HAlign(HAlign_Left)
				.Padding(headerMargin)
				[
					SNew(STextBlock)
					.Text(LOCTEXT("LumenCacheResolutionText", "Lumen Cache Resolution"))
				]
				+SHorizontalBox::Slot()
				.FillWidth(valueWidth)
				.HAlign(HAlign_Right)
				.Padding(valueMargin)
				[
					SNew(SNumericEntryBox<float>)
					.Font(FAppStyle::GetFontStyle(TEXT("MenuItem.Font")))
					.AllowSpin(true)
					.MinValue(0.0f)
					.MaxValue(5.0f)
					.MinSliderValue(0.5)
					.MaxSliderValue(2.0)
					.Delta(0.01f)
					.LinearDeltaSensitivity(0.001f)
					.Value(this, &SCyberGafferWindowContent::GetLumenCacheResolution)
					.OnValueChanged(this, &SCyberGafferWindowContent::OnLumenCacheResolutionValueChanged)
					.ToolTipText(LOCTEXT("LumenCacheResolutionText", "Lumen Cache Resolution"))
					.IsEnabled(this, &SCyberGafferWindowContent::IsCyberGafferSceneCaptureComponentValid)
					.MinDesiredValueWidth(75.0f)
				]
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(verticalSlotPadding)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.AutoWidth()
				.HAlign(HAlign_Center)
				.Padding(headerMargin)
				[
					SNew(SButton)
					.Text(LOCTEXT("RecompileShadersText", "Recompile Shaders"))
					.OnClicked(this, &SCyberGafferWindowContent::RecompileShaders)
				]
				
			]
		]
		+SScrollBox::Slot()
		.FillSize(1.0f)
		[
			SNew(SBox)
			.VAlign(VAlign_Bottom)
			.HAlign(HAlign_Center)
			.Padding(10.0f)
			[
				SNew(SImage)
				.Image(cyberGafferLogo)
			]
		]
	];
}

void SCyberGafferWindowContent::OnParentTabClosed(TSharedRef<SDockTab> parentTab) {
	CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnParentTabClosed"));

	TSharedPtr<SDockTab> currentTab = _containingTab.Pin();
	if (currentTab.IsValid()) {
		if (currentTab == parentTab) {
			FEditorDelegates::OnMapOpened.Remove(_currentSceneChangedDelegateHandle);
		} else {
			CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnParentTabClosed: tab mismatch"));
		}
	} else {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnParentTabClosed: current tab is invalid"));
	}
}

UMaterialInstance* SCyberGafferWindowContent::LoadMaterialUsingPath(const FString& path) {
	if (path.IsEmpty()) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::LoadMaterialUsingPath: path is empty"));
		return nullptr;
	}
	
	FAssetRegistryModule& module = FModuleManager::GetModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry"));
	FAssetData assetData;
	FSoftObjectPath objectPath(path);
	if (module.Get().TryGetAssetByObjectPath(objectPath, assetData) == UE::AssetRegistry::EExists::Exists) {
		return Cast<UMaterialInstance>(assetData.GetAsset());
	}
	
	CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::LoadMaterialUsingPath: failed to load asset at path %s"), *path);
	return nullptr;
}

TOptional<FString> SCyberGafferWindowContent::GetCurrentSceneName() {
	UWorld* world = GEditor->GetEditorWorldContext().World();
	if (!world) {
		CYBERGAFFER_LOG(Warning, TEXT(" SCyberGafferWindowContent::GetCurrentSceneName: world is null"));
		return TOptional<FString>();
	}

	const UPackage* worldPackage = world->GetPackage();
	const FString worldPackageName = worldPackage->GetName();
	_isTempScene = FPackageName::IsTempPackage(worldPackageName);

	// FPackageName::Name
	// CYBERGAFFER_LOG(Warning, TEXT(" SCyberGafferWindowContent::GetCurrentSceneName: outermost file path: %s, temp: %i"), *mapName, isTemp);
	if (_isTempScene) {
		if (!_tempSceneSavedDelegateHandle.IsValid()) {
			_tempSceneSavedDelegateHandle = FEditorDelegates::PostSaveWorldWithContext.AddRaw(this, &SCyberGafferWindowContent::OnTempSceneSaved);
		}
		
		CYBERGAFFER_LOG(Warning, TEXT(" SCyberGafferWindowContent::GetCurrentSceneName: scene file doesn't saved yet"));
		return TOptional<FString>();
	} else {		
		if (_tempSceneSavedDelegateHandle.IsValid()) {
			FEditorDelegates::PostSaveWorldWithContext.Remove(_tempSceneSavedDelegateHandle);
			_tempSceneSavedDelegateHandle.Reset();
		}
	}
	
	const auto shortPackageName = FPackageName::GetShortName(worldPackageName);
	CYBERGAFFER_LOG(Warning, TEXT("SCyberGafferWindowContent::GetCurrentSceneName: package name: %s"), *shortPackageName);

	return shortPackageName;
}

void SCyberGafferWindowContent::OnSceneChanged(const FString& filename, bool asTemplate) {
	const TOptional<FString> sceneName = GetCurrentSceneName();
	if (sceneName.IsSet()) {
		const auto sceneSettings = _settings->ScenesSettings.Find(sceneName.GetValue());
		if (sceneSettings) {
			_linearPostProcessMaterial = LoadMaterialUsingPath(sceneSettings->LinearPostProcessMaterial);
			_colorGradingPostProcessMaterial = LoadMaterialUsingPath(sceneSettings->ColorGradingPostProcessMaterial);
			
			FSoftObjectPath postProcessVolumePath(sceneSettings->PostProcessVolumePath);
			auto postProcessVolume = postProcessVolumePath.ResolveObject();
			if (postProcessVolume) {
				_postProcessVolume = Cast<APostProcessVolume>(postProcessVolume);
				// _postProcessVolumePath = postProcessVolume->GetPathName();
			}

			FSoftObjectPath cyberGafferSceneCapturePath(sceneSettings->CyberGafferSceneCapturePath);
			auto cyberGafferSceneCapture = cyberGafferSceneCapturePath.ResolveObject();
			if (cyberGafferSceneCapture) {
				_cyberGafferSceneCapture = Cast<ACyberGafferSceneCapture>(cyberGafferSceneCapture);
				_cyberGafferSceneCaptureComponent = FindCyberGafferSceneCaptureComponent();
				// _cyberGafferSceneCapturePath = postProcessVolume->GetPathName();
			}
		} else {
			_settings->ScenesSettings.Add(sceneName.GetValue(), FCyberGafferWindowSceneSettings());
			_linearPostProcessMaterial = nullptr;
			_colorGradingPostProcessMaterial = nullptr;
			_postProcessVolume = nullptr;
			_settings->SaveConfig();
			if (!_settings->TryUpdateDefaultConfigFile()) {
				FMessageDialog::Open(EAppMsgType::Ok, LOCTEXT("FailedToSaveDefaultSettings_Text", "Unable to save settings"));
			}
		}
	}
}

void SCyberGafferWindowContent::OnTempSceneSaved(UWorld* world, FObjectPostSaveContext postSaveContext) {
	OnSceneChanged(FString(), false);
}

FReply SCyberGafferWindowContent::CreatePostProcessMaterialInstance(const PostProcessMaterialType type) {
	IAssetTools& assetTools = FModuleManager::GetModuleChecked<FAssetToolsModule>("AssetTools").Get();
	UMaterialInstanceConstantFactoryNew* materialFactory = NewObject<UMaterialInstanceConstantFactoryNew>();

	FString initialParentPath;
	switch (type) {
	case Linear: {
			initialParentPath = "Script/Engine.Material'/CyberGaffer/Materials/CyberGafferLinearPostProcess.CyberGafferLinearPostProcess'";
			break;
		}
	case ColorGrading: {
			initialParentPath = "Script/Engine.Material'/CyberGaffer/Materials/CyberGafferColorGradingPostProcess.CyberGafferColorGradingPostProcess'";
			break;
		}
	}
	
	UMaterialInterface* initialParent = Cast<UMaterialInterface>(StaticLoadObject(UMaterial::StaticClass(), nullptr, *initialParentPath));
	if (initialParent == nullptr) {
		return FReply::Unhandled();
	}
	
	const auto cyberGafferProjectContentDir = FString("/Game/CyberGaffer");
	const TOptional<FString> sceneName = GetCurrentSceneName();
	const auto newAssetName = FString::Printf(TEXT("%s_%s"), *initialParent->GetName(), *sceneName.GetValue());

	const FString packagePath = UPackageTools::SanitizePackageName(cyberGafferProjectContentDir + TEXT("/") + newAssetName);
	
	const FString newAssetPath = FPaths::Combine(FPaths::ProjectContentDir(), "CyberGaffer", *newAssetName) + ".uasset";
	if (FPaths::FileExists(newAssetPath)) {
		FMessageDialog::Open(EAppMsgType::Ok, LOCTEXT("FileExistsText", "File already exists"));
		return FReply::Handled();
	}
	
	materialFactory->InitialParent = initialParent;
	UObject* asset = assetTools.CreateAsset(newAssetName, cyberGafferProjectContentDir, UMaterialInstanceConstant::StaticClass(), materialFactory);
	if (asset == nullptr) {
		return FReply::Unhandled();
	}

	auto newMaterail = Cast<UMaterialInstanceConstant>(asset);

	switch (type) {
	case Linear: {
		_linearPostProcessMaterial = newMaterail;
		OnLinearPostProcessMaterialSelectorValueChanged(newMaterail);
		break;
	}
	case ColorGrading: {
		_colorGradingPostProcessMaterial = newMaterail;
		OnColorGradingPostProcessMaterialSelectorValueChanged(newMaterail);
		break;
	}
	}

	SaveMaterialChanges(newMaterail);

	return FReply::Handled();
}

FString SCyberGafferWindowContent::GetLinearPostProcessMaterialPath() const {
	if (_linearPostProcessMaterial.IsValid()) {
		return _linearPostProcessMaterial->GetPathName();
	}

	return FString();
}

void SCyberGafferWindowContent::OnLinearPostProcessMaterialSelectorValueChanged(const FAssetData& assetData) {
	const TOptional<FString> currentSceneName = GetCurrentSceneName();
	if (!currentSceneName.IsSet()) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnLinearPostProcessMaterialSelectorValueChanged: current scene name is null"));
		return;
	}
	
	TOptional<FCyberGafferWindowSceneSettings*> sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	if (!sceneSettings.IsSet()) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnLinearPostProcessMaterialSelectorValueChanged: current scene settings is null, scene: %s"), *currentSceneName.GetValue());
		return;
	}
	
	UMaterialInstance* materialInstance = Cast<UMaterialInstance>(assetData.GetAsset());
	if (materialInstance) {
		auto materialPath = materialInstance->GetPathName();
		sceneSettings.GetValue()->LinearPostProcessMaterial = materialPath;
	} else {
		sceneSettings.GetValue()->LinearPostProcessMaterial = "";
	}
	
	_settings->SaveConfig();
	if (!_settings->TryUpdateDefaultConfigFile()) {
		FMessageDialog::Open(EAppMsgType::Ok, LOCTEXT("FailedToSaveDefaultSettings_Text", "Unable to save settings"));
	}
	
	_linearPostProcessMaterial = materialInstance;
}

FString SCyberGafferWindowContent::GetColorGradingPostProcessMaterialPath() const {
	if (_colorGradingPostProcessMaterial.IsValid()) {
		return _colorGradingPostProcessMaterial->GetPathName();
	}

	return FString();
}

void SCyberGafferWindowContent::OnColorGradingPostProcessMaterialSelectorValueChanged(const FAssetData& assetData) {
	const TOptional<FString> currentSceneName = GetCurrentSceneName();
	if (!currentSceneName.IsSet()) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnColorGradingPostProcessMaterialSelectorValueChanged: current scene name is null"));
		return;
	}
	
	TOptional<FCyberGafferWindowSceneSettings*> sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	if (!sceneSettings.IsSet()) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnColorGradingPostProcessMaterialSelectorValueChanged: current scene settings is null"));
		return;
	}
	
	UMaterialInstance* materialInstance = Cast<UMaterialInstance>(assetData.GetAsset());
	if (materialInstance) {
		sceneSettings.GetValue()->ColorGradingPostProcessMaterial = materialInstance->GetPathName();
	} else {
		sceneSettings.GetValue()->ColorGradingPostProcessMaterial = "";
	}
	_settings->SaveConfig();
	if (!_settings->TryUpdateDefaultConfigFile()) {
		FMessageDialog::Open(EAppMsgType::Ok, LOCTEXT("FailedToSaveDefaultSettings_Text", "Unable to save settings"));
	}
	
	_colorGradingPostProcessMaterial = materialInstance;
}

TOptional<float> SCyberGafferWindowContent::GetExposureCompensation() const {
	if (!IsColorGradingPostProcessMaterialValid()) {
		return 0.0f;
	}
	
	FMemoryImageMaterialParameterInfo parameterInfo(TEXT("Expose Compensation"));
	FMaterialParameterMetadata metadata;
	const bool callResult = _colorGradingPostProcessMaterial->GetParameterValue(EMaterialParameterType::Scalar, parameterInfo, metadata);
	
	if (callResult) {
		return metadata.Value.AsScalar();
	}
	return 0.0f;
}

void SCyberGafferWindowContent::OnExposureCompensationValueChanged(float value) {
	if (!IsColorGradingPostProcessMaterialValid()) {
		return;
	}

	auto instanceConstant = Cast<UMaterialInstanceConstant>(_colorGradingPostProcessMaterial);
	if (instanceConstant) {
		FMaterialParameterInfo parameterInfo(TEXT("Expose Compensation"));
		instanceConstant->SetScalarParameterValueEditorOnly(parameterInfo, value);
	}
}

void SCyberGafferWindowContent::OnExposureCompensationValueCommited(const float newValue, ETextCommit::Type commitType) {
	OnExposureCompensationValueChanged(newValue);
	SaveMaterialChanges(_colorGradingPostProcessMaterial.Get());
}

FLinearColor SCyberGafferWindowContent::GetColorGradingColor() const {
	if (!IsColorGradingPostProcessMaterialValid()) {
		return FLinearColor::White;
	}

	FMemoryImageMaterialParameterInfo parameterInfo(TEXT("Multiplier"));
	FMaterialParameterMetadata metadata;
	const bool callResult = _colorGradingPostProcessMaterial->GetParameterValue(EMaterialParameterType::Vector, parameterInfo, metadata);
	
	if (callResult) {
		return metadata.Value.AsLinearColor().LinearRGBToHSV();
	}

	return FLinearColor::White;
}

void SCyberGafferWindowContent::OnColorGradingValueChanged(FLinearColor color) {
	if (!IsColorGradingPostProcessMaterialValid()) {
		return;
	}

	auto instanceConstant = Cast<UMaterialInstanceConstant>(_colorGradingPostProcessMaterial);
	FMaterialParameterInfo parameterInfo(TEXT("Multiplier"));
	if (instanceConstant) {
		instanceConstant->SetVectorParameterValueEditorOnly(parameterInfo, color.HSVToLinearRGB());
	}
}

void SCyberGafferWindowContent::OnColorGradingCaptureEnd() {
	SaveMaterialChanges(_colorGradingPostProcessMaterial.Get());
}

bool SCyberGafferWindowContent::IsColorGradingPostProcessMaterialValid() const {
	return _colorGradingPostProcessMaterial.IsValid();
}

FString SCyberGafferWindowContent::GetPostProcessVolumePath() const {
	// return _postProcessVolumePath;
	return _postProcessVolume == nullptr ? "" : _postProcessVolume->GetPathName();
}

void SCyberGafferWindowContent::OnPostProcessVolumePathChanged(const FAssetData& assetData) {
	auto objPath = assetData.GetSoftObjectPath();
	auto obj = objPath.ResolveObject();

	if (obj == nullptr) {
		_postProcessVolume = nullptr;
		// _postProcessVolumePath = "";
	} else {
		_postProcessVolume = Cast<APostProcessVolume>(obj);
		// _postProcessVolumePath = assetData.GetObjectPathString();
	}

	SavePostProcessVolumePath();
}

void SCyberGafferWindowContent::SavePostProcessVolumePath() {
	auto sceneSettings = _settings->GetSettingsForCurrentScene();
	if (!sceneSettings.IsSet()) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::SavePostProcessVolumePath: current scene settings is null"));
		return;
	}

	// sceneSettings.GetValue()->PostProcessVolumePath = _postProcessVolumePath;
	sceneSettings.GetValue()->PostProcessVolumePath = _postProcessVolume == nullptr ? "" : _postProcessVolume->GetPathName();
	_settings->SaveConfig();
	if (!_settings->TryUpdateDefaultConfigFile()) {
		FMessageDialog::Open(EAppMsgType::Ok, LOCTEXT("FailedToSaveDefaultSettings_Text", "Unable to save settings"));
	}
}

bool SCyberGafferWindowContent::IsCyberGafferSceneCaptureComponentValid() const {
	return _cyberGafferSceneCaptureComponent != nullptr;
}

UCyberGafferSceneCaptureComponent2D* SCyberGafferWindowContent::FindCyberGafferSceneCaptureComponent() const {
	if (_cyberGafferSceneCapture == nullptr) {
		return nullptr;
	}
	
	TArray<UCyberGafferSceneCaptureComponent2D*> components;
	_cyberGafferSceneCapture->GetComponents(components);
	if (components.Num() == 0) {
		return nullptr;
	}
	UCyberGafferSceneCaptureComponent2D* sceneCaptureComponent = components[0];
	if (sceneCaptureComponent == nullptr) {
		return nullptr;
	}

	return sceneCaptureComponent;
}

FString SCyberGafferWindowContent::GetCyberGafferSceneCapturePath() const {
	// return _cyberGafferSceneCapturePath;
	return _cyberGafferSceneCapture == nullptr ? "" : _cyberGafferSceneCapture->GetPathName();
}

void SCyberGafferWindowContent::OnCyberGafferSceneCaptureChanged(const FAssetData& assetData) {
	auto objPath = assetData.GetSoftObjectPath();
	auto obj = objPath.ResolveObject();

	if (obj == nullptr) {
		_cyberGafferSceneCapture = nullptr;
		_cyberGafferSceneCaptureComponent = nullptr;
		// _cyberGafferSceneCapturePath = "";
	} else {
		_cyberGafferSceneCapture = Cast<ACyberGafferSceneCapture>(obj);
		_cyberGafferSceneCaptureComponent = FindCyberGafferSceneCaptureComponent();
		// _cyberGafferSceneCapturePath = assetData.GetObjectPathString();
	}

	SaveCyberGafferSceneCapturePath();
}

void SCyberGafferWindowContent::SaveCyberGafferSceneCapturePath() {
	auto sceneSettings = _settings->GetSettingsForCurrentScene();
	if (!sceneSettings.IsSet()) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::SaveCyberGafferSceneCapturePath: current scene settings is null"));
		return;
	}

	// sceneSettings.GetValue()->CyberGafferSceneCapturePath = _cyberGafferSceneCapturePath;
	sceneSettings.GetValue()->CyberGafferSceneCapturePath = _cyberGafferSceneCapture == nullptr ? "" : _cyberGafferSceneCapture->GetPathName();
	_settings->SaveConfig();
	if (!_settings->TryUpdateDefaultConfigFile()) {
		FMessageDialog::Open(EAppMsgType::Ok, LOCTEXT("FailedToSaveDefaultSettings_Text", "Unable to save settings"));
	}
}

TOptional<float> SCyberGafferWindowContent::GetLumenCacheResolution() const {
	if (_cyberGafferSceneCaptureComponent == nullptr) {
		return TOptional<float>();
	}

	return _cyberGafferSceneCaptureComponent->PostProcessSettings.LumenSurfaceCacheResolution;
}

void SCyberGafferWindowContent::OnLumenCacheResolutionValueChanged(float value) {
	if (_cyberGafferSceneCaptureComponent == nullptr) {
		return;
	}

	_cyberGafferSceneCaptureComponent->PostProcessSettings.LumenSurfaceCacheResolution = value;
}

FText SCyberGafferWindowContent::GetShadersIncludePath() const {
	if (!_settings) {
		return FText();
	}

	return _settings->ShadersIncludePath;
}

void SCyberGafferWindowContent::OnShadersIncludePathCommitted(const FText& newText, ETextCommit::Type commitType) {
	if (!_settings) {
		return;
	}
	
	if (newText.CompareTo(_settings->ShadersIncludePath) == 0) {
		return;
	}

	if (!FPaths::DirectoryExists(newText.ToString())) {
		CYBERGAFFER_LOG(Log, TEXT("SCyberGafferWindowContent::OnShadersIncludePathCommitted: invalid path"));
		return;
	}

	const FString shadersDir = FModuleManager::Get().GetModuleChecked<FCyberGafferModule>("CyberGaffer").GetShaderDirectory();
	FString shadersIncludePath = FPaths::Combine(shadersDir, "Include");
	shadersIncludePath = shadersIncludePath.Replace(TEXT("/"), TEXT("\\"));
	if (FPaths::DirectoryExists(shadersIncludePath)) {
		const FString command = FString::Printf(TEXT("/c rd \"%s\""), *shadersIncludePath);
		FProcHandle result = FPlatformProcess::CreateProc(TEXT("cmd.exe"), *command, false, true, false, nullptr, 0, nullptr, nullptr, nullptr);

		while (FPlatformProcess::IsProcRunning(result)) {
			FPlatformProcess::Sleep(0.1f);
		}
	}

	if (FPaths::DirectoryExists(shadersIncludePath)) {
		CYBERGAFFER_LOG(Error, TEXT("SCyberGafferWindowContent::OnShadersIncludePathCommitted: failed to delete junction"));
		return;
	}

	const FString command = FString::Printf(TEXT("/c mklink /j \"%s\" \"%s\""), *shadersIncludePath, *newText.ToString().Replace(TEXT("/"), TEXT("\\")));
	FPlatformProcess::CreateProc(TEXT("cmd.exe"), *command, false, true, false, nullptr, 0, nullptr, nullptr, nullptr);

	_settings->ShadersIncludePath = newText;
	_settings->SaveConfig();
	if (!_settings->TryUpdateDefaultConfigFile()) {
		FMessageDialog::Open(EAppMsgType::Ok, LOCTEXT("FailedToSaveDefaultSettings_Text", "Unable to save settings"));
	}

	RecompileShaders();
	
	// FLevelEditorActionCallbacks::ExecuteExecCommand(TEXT("RECOMPILESHADERS CHANGED"));
}

void SCyberGafferWindowContent::SaveMaterialChanges(UMaterialInterface* material) {
	if (material == nullptr) {
		return;
	}

	TArray<UMaterialInterface*> materials;
	materials.Add(material);
	SaveMaterialsChanges(materials);
}

void SCyberGafferWindowContent::SaveMaterialsChanges(const TArray<UMaterialInterface*>& materials) {
	if (materials.IsEmpty()) {
		return;
	}
	
	TArray<UPackage*> packagesToSave;

	for (auto material : materials) {
		material->PostEditChange();
		material->MarkPackageDirty();
		packagesToSave.Add(material->GetOutermost());
	}

	FEditorFileUtils::PromptForCheckoutAndSave(packagesToSave, true, false);
}

FReply SCyberGafferWindowContent::RecompileShaders() {
	TArray<UMaterialInterface*> materials;
	if (_linearPostProcessMaterial != nullptr) {
		materials.Add(_linearPostProcessMaterial->GetMaterial());
		materials.Add(_linearPostProcessMaterial.Get());

		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_linearPostProcessMaterial->GetMaterial()->GetName()));
		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_linearPostProcessMaterial->GetName()));
	}
	if (_colorGradingPostProcessMaterial != nullptr) {
		materials.Add(_colorGradingPostProcessMaterial->GetMaterial());
		materials.Add(_colorGradingPostProcessMaterial.Get());

		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_colorGradingPostProcessMaterial->GetMaterial()->GetName()));
		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_colorGradingPostProcessMaterial->GetName()));
	}

	SaveMaterialsChanges(materials);

	return FReply::Handled();
}

#undef LOCTEXT_NAMESPACE
