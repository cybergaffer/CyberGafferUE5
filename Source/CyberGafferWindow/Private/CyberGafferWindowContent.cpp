// Fill out your copyright notice in the Description page of Project Settings.


#include "CyberGafferWindowContent.h"

#include "Widgets/Docking/SDockTab.h"
#include "Widgets/SBoxPanel.h"
#include "Widgets/Layout/SBorder.h"
#include "Widgets/Layout/SGridPanel.h"
#include "Widgets/Text/STextBlock.h"
#include "Widgets/Input/SNumericEntryBox.h"
#include "Layout/Margin.h"
#include "Styling/AppStyle.h"
#include "UObject/ConstructorHelpers.h"

// #include "DetailsViewArgs.h"
#include "IStructureDetailsView.h"
#include "Materials/MaterialInstanceConstant.h"
#include "Modules/ModuleManager.h"
#include "Widgets/Colors/SColorWheel.h"
// #include "PropertyEditorModule.h"
// #include "UObject/StructOnScope.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Editor/UnrealEd/Public/FileHelpers.h"
#include "CyberGaffer.h"
#include "Editor/LevelEditor/Public/LevelEditorActions.h"
#include "AssetToolsModule.h"
#include "Factories/MaterialInstanceConstantFactoryNew.h"

#define LOCTEXT_NAMESPACE "FCyberGafferWindowModule"

// CyberGafferWindowContent::CyberGafferWindowContent() { }
// CyberGafferWindowContent::~CyberGafferWindowContent() { }

void SCyberGafferWindowContent::Construct(const FArguments& args) {
	// Code for DetailView autogenerated UI
	// FStructureDetailsViewArgs structureDetailsViewArgs;
	// FDetailsViewArgs detailsViewArgs;
	// detailsViewArgs.bAllowSearch = false;

	// auto& propertyEditor = FModuleManager::Get().LoadModuleChecked<FPropertyEditorModule>(TEXT("PropertyEditor"));
	// _windowFields = MakeShared<FStructOnScope>(FCyberGafferWindowFields::StaticStruct());
	// _detailsView = propertyEditor.CreateStructureDetailView(detailsViewArgs, structureDetailsViewArgs, _windowFields);
	// _detailsView->GetOnFinishedChangingPropertiesDelegate().AddSP(this, &SCyberGafferWindowContent::OnPropertiesChanged);

	_settings = TStrongObjectPtr<UCyberGafferWindowSettings>(NewObject<UCyberGafferWindowSettings>());

	ReadCurrentSceneName();

	if (_currentSceneName.IsSet()) {
		auto sceneSettings = _settings->ScenesSettings.Find(_currentSceneName.GetValue());
		if (sceneSettings) {
			_postProcessMaterial = LoadMaterialUsingPath(sceneSettings->PostProcessMaterial);
			_cameraPostProcessMaterial = LoadMaterialUsingPath(sceneSettings->CameraPostProcessMaterial);
		} else {
			_settings->ScenesSettings.Add(_currentSceneName.GetValue(), FCyberGafferWindowSceneSettings());
			_settings->SaveConfig();
		}
	}
	
	_postProcessMaterialSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetPostProcessMaterialPath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(UMaterialInstance::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged));
	
	_cameraPostProcessMaterialSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetCameraPostProcessMaterialPath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(UMaterialInstance::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged));

	auto separator = SNew(SSeparator).Orientation(Orient_Vertical);

	const float headerWidth = 0.4f;
	const float valueWidth = 0.6f;

	const FMargin headerMargin = FMargin(5, 0, 10, 0);
	const FMargin valueMargin = FMargin(10, 0, 5, 0);
	
	ChildSlot [
		// Code for DetailView autogenerated UI
		// _detailsView->GetWidget().ToSharedRef()
		
		SNew(SVerticalBox)
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Center)
			.Padding(headerMargin)
			[
				SNew(SButton)
				.Text(LOCTEXT("CreateNewPPMIText", "Create new post process material for scene"))
				.OnClicked(this, &SCyberGafferWindowContent::CreatePostProcessMaterialInstance, PostProcessMaterialType::Global)
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Center)
			.Padding(headerMargin)
			[
				SNew(SButton)
				.Text(LOCTEXT("CreateNewCPPMIText", "Create new camera post process material for scene"))
			]
			
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("PostProcessMaterialText", "Post Process Material"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				_postProcessMaterialSelector.ToSharedRef()
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("PostProcessMaterialText", "Camera Post Process Material"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				_cameraPostProcessMaterialSelector.ToSharedRef()
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SSeparator)
			.Orientation(Orient_Horizontal)
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("ExposureCompensationText", "ExposureCompensation"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				SNew(SNumericEntryBox<float>)
				.Font(FAppStyle::GetFontStyle(TEXT("MenuItem.Font")))
				.AllowSpin(true)
				.MinValue(TOptional<float>())
				.MaxValue(TOptional<float>())
				.MinSliderValue(-10.0)
				.MaxSliderValue(10.0)
				.Delta(0.01f)
				.LinearDeltaSensitivity(0.001f)
				.Value(this, &SCyberGafferWindowContent::GetExposureCompensation)
				.OnValueChanged(this, &SCyberGafferWindowContent::OnExposureCompensationValueChanged)
				.OnValueCommitted(this, &SCyberGafferWindowContent::OnExposureCompensationValueCommited)
				.ToolTipText(LOCTEXT("ExposureCompensationText", "Exposure Compensation"))
				.IsEnabled(this, &SCyberGafferWindowContent::IsPostProcessMaterialValid)
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("ColorGradingText", "Color Grading"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				SNew(SColorWheel)
				.SelectedColor(this, &SCyberGafferWindowContent::GetColorGradingColor)
				.OnValueChanged(this, &SCyberGafferWindowContent::OnColorGradingValueChanged)
				.OnMouseCaptureEnd(this, &SCyberGafferWindowContent::OnColorGradingCaptureEnd)
				.ToolTipText(LOCTEXT("ExposureCompensationText", "Exposure Compensation"))
				.IsEnabled(this, &SCyberGafferWindowContent::IsPostProcessMaterialValid)
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("ShadersIncludePathText", "Shaders Include Path"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				SNew(SEditableTextBox)
				.Font(FAppStyle::GetFontStyle(TEXT("MenuItem.Font")))
				.Text(this, &SCyberGafferWindowContent::GetShadersIncludePath)
				.OnTextCommitted(this, &SCyberGafferWindowContent::OnShadersIncludePathCommitted)
			]
		]
	];
}

// void SCyberGafferWindowContent::OnPropertiesChanged(const FPropertyChangedEvent& propertyChangedEvent) {
// 	const auto name = propertyChangedEvent.GetMemberPropertyName();
// 	UE_LOG(LogTemp, Log, TEXT("%s"), *name.ToString());
// }

UMaterialInstance* SCyberGafferWindowContent::LoadMaterialUsingPath(const FString& path) {
	if (path.IsEmpty()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::LoadMaterialUsingPath: path is empty"));
		return nullptr;
	}
	
	auto& module = FModuleManager::GetModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry"));
	FAssetData assetData;
	FSoftObjectPath objectPath(path);
	if (module.Get().TryGetAssetByObjectPath(objectPath, assetData) == UE::AssetRegistry::EExists::Exists) {
		return Cast<UMaterialInstance>(assetData.GetAsset());
	}
	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::LoadMaterialUsingPath: failed to load asset at path %s"), *path);
	return nullptr;
}

FString SCyberGafferWindowContent::GetPostProcessMaterialPath() const {
	// auto currentSceneName = GetCurrentSceneName();
	// if (!currentSceneName.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetPostProcessMaterialPath: current scene name is null"));
	// 	return FString();
	// }
	//
	// auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	// if (!sceneSettings.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetPostProcessMaterialPath: current scene settings is null"));
	// 	return FString();
	// }
	//
	// auto postProcessMaterial = sceneSettings.GetValue().PostProcessMaterial;
	//
	// if (postProcessMaterial != nullptr) {
	// 	return postProcessMaterial->GetPathName();
	// }

	if (_postProcessMaterial.IsValid()) {
		return _postProcessMaterial->GetPathName();
	}

	return FString();
}

void SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged(const FAssetData& assetData) {
	auto currentSceneName = GetCurrentSceneName();
	if (!currentSceneName.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged: current scene name is null"));
		return;
	}
	
	auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	if (!sceneSettings.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged: current scene settings is null, scene: %s"), *currentSceneName.GetValue());
		return;
	}
	
	UMaterialInstance* materialInstance = Cast<UMaterialInstance>(assetData.GetAsset());
	if (materialInstance) {
		// _postProcessMaterial = MakeWeakObjectPtr<UMaterialInstance>(materialInstance);
		auto materialPath = materialInstance->GetPathName();
		sceneSettings.GetValue()->PostProcessMaterial = materialPath;
	} else {
		// _postProcessMaterial = nullptr;
		sceneSettings.GetValue()->PostProcessMaterial = "";
	}
	_settings->SaveConfig();
	
	_postProcessMaterial = materialInstance;
}

FString SCyberGafferWindowContent::GetCameraPostProcessMaterialPath() const {
	// auto currentSceneName = GetCurrentSceneName();
	// if (!currentSceneName.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetCameraPostProcessMaterialPath: current scene name is null"));
	// 	return FString();
	// }
	//
	// auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	// if (!sceneSettings.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetCameraPostProcessMaterialPath: current scene settings is null"));
	// 	return FString();
	// }
	//
	// auto cameraPostProcessMaterial = sceneSettings.GetValue().CameraPostProcessMaterial;
	//
	// if (cameraPostProcessMaterial != nullptr) {
	// 	return cameraPostProcessMaterial->GetPathName();
	// }

	if (_cameraPostProcessMaterial.IsValid()) {
		return _cameraPostProcessMaterial->GetPathName();
	}

	return FString();
}

void SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged(const FAssetData& assetData) {
	auto currentSceneName = GetCurrentSceneName();
	if (!currentSceneName.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged: current scene name is null"));
		return;
	}
	
	auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	if (!sceneSettings.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged: current scene settings is null"));
		return;
	}
	
	UMaterialInstance* materialInstance = Cast<UMaterialInstance>(assetData.GetAsset());
	if (materialInstance) {
		// _cameraPostProcessMaterial = MakeWeakObjectPtr<UMaterialInstance>(materialInstance);
		sceneSettings.GetValue()->CameraPostProcessMaterial = materialInstance->GetPathName();
	} else {
		// _cameraPostProcessMaterial = nullptr;
		sceneSettings.GetValue()->CameraPostProcessMaterial = "";
	}
	_settings->SaveConfig();
	
	_cameraPostProcessMaterial = materialInstance;
}

TOptional<float> SCyberGafferWindowContent::GetExposureCompensation() const {
	if (!IsPostProcessMaterialValid()) {
		return 0.0f;
	}
	FMemoryImageMaterialParameterInfo parameterInfo(TEXT("Expose Compensation"));
	FMaterialParameterMetadata metadata;
	const auto callResult = _postProcessMaterial->GetParameterValue(EMaterialParameterType::Scalar, parameterInfo, metadata);
	
	if (callResult) {
		return metadata.Value.AsScalar();
	}

	return 0.0f;
}

void SCyberGafferWindowContent::OnExposureCompensationValueChanged(float value) {
	if (!IsPostProcessMaterialValid()) {
		return;
	}

	auto instanceConstant = Cast<UMaterialInstanceConstant>(_postProcessMaterial);
	FMaterialParameterInfo parameterInfo(TEXT("Expose Compensation"));
	if (instanceConstant) {
		instanceConstant->SetScalarParameterValueEditorOnly(parameterInfo, value);
	}
}

void SCyberGafferWindowContent::OnExposureCompensationValueCommited(const float newValue, ETextCommit::Type commitType) {
	OnExposureCompensationValueChanged(newValue);

	SaveMaterialChanges(_postProcessMaterial);
}

TOptional<FString> SCyberGafferWindowContent::ReadCurrentSceneName() {
	auto world = GEditor->GetEditorWorldContext().World();
	if (!world) {
		return TOptional<FString>();
	}
	
	auto sceneName = world->GetMapName();
	if (sceneName.IsEmpty()) {
		return TOptional<FString>();
	}

	auto sceneBaseName = FPaths::GetBaseFilename(sceneName);
	SetCurrentSceneName(sceneName);
	
	return sceneBaseName;
}

TOptional<FString> SCyberGafferWindowContent::GetCurrentSceneName() const {
	FScopeLock lock(&_currentSceneNameCriticalSection);
	return _currentSceneName;
}

void SCyberGafferWindowContent::SetCurrentSceneName(const FString& newSceneName) {
	FScopeLock lock(&_currentSceneNameCriticalSection);
	if (newSceneName.IsEmpty()) {
		_currentSceneName.Reset();
	} else {
		_currentSceneName = newSceneName;
	}
}

void SCyberGafferWindowContent::SaveMaterialChanges(TWeakObjectPtr<UMaterialInterface> material) {
	material->PostEditChange();
	material->MarkPackageDirty();

	TArray<UPackage*> packagesToSave;
	packagesToSave.Add(material->GetOutermost());

	FEditorFileUtils::PromptForCheckoutAndSave(packagesToSave, true, /*bPromptToSave=*/ false);
}

void SCyberGafferWindowContent::SaveMaterialsChanges(TArray<UMaterialInterface*> materials) {
	TArray<UPackage*> packagesToSave;

	for (auto material : materials) {
		material->PostEditChange();
		material->MarkPackageDirty();
		packagesToSave.Add(material->GetOutermost());
	}

	FEditorFileUtils::PromptForCheckoutAndSave(packagesToSave, true, /*bPromptToSave=*/ false);
}

bool SCyberGafferWindowContent::IsPostProcessMaterialValid() const {
	return _postProcessMaterial.IsValid();
}

FReply SCyberGafferWindowContent::CreatePostProcessMaterialInstance(const PostProcessMaterialType type) {
	auto& assetTools = FModuleManager::GetModuleChecked<FAssetToolsModule>("AssetTools").Get();
	auto materialFactory = NewObject<UMaterialInstanceConstantFactoryNew>();

	FString initialParentPath;
	switch (type) {
	case Global: {
			initialParentPath = "Script/Engine.Material'/CyberGaffer/Materials/CyberGafferPostProcess.CyberGafferPostProcess'";
			break;
		}
	case Camera: {
			initialParentPath = "Script/Engine.Material'/CyberGaffer/Materials/CyberGafferCameraPostProcess.CyberGafferCameraPostProcess'";
			break;
		}
	}
	auto initialParent = Cast<UMaterialInterface>(StaticLoadObject(UMaterial::StaticClass(), nullptr, *initialParentPath));
	if (initialParent == nullptr) {
		return FReply::Unhandled();
	}
	
	const auto cyberGafferProjectContentDir = "/Game/Content/CyberGaffer";
	const auto sceneName = ReadCurrentSceneName();
	const auto newAssetName = FString::Printf(TEXT("%s_%s"), *initialParent->GetName(), *sceneName.GetValue());
	
	materialFactory->InitialParent = initialParent;
	auto asset = assetTools.CreateAsset(newAssetName, cyberGafferProjectContentDir, UMaterialInstanceConstant::StaticClass(), materialFactory);

	if (asset == nullptr) {
		return FReply::Unhandled();
	}

	auto newMaterail = Cast<UMaterialInstanceConstant>(asset);

	switch (type) {
	case Global: {
		_postProcessMaterial = newMaterail;
		OnPostProcessMaterialSelectorValueChanged(newMaterail);
		break;
	}
	case Camera: {
		_cameraPostProcessMaterial = newMaterail;
		OnCameraPostProcessMaterialSelectorValueChanged(newMaterail);
		break;
	}
	}

	return FReply::Handled();
}

FLinearColor SCyberGafferWindowContent::GetColorGradingColor() const {
	if (!IsPostProcessMaterialValid()) {
		return FLinearColor::White;
	}

	FMemoryImageMaterialParameterInfo parameterInfo(TEXT("Multiplier"));
	FMaterialParameterMetadata metadata;
	const auto callResult = _postProcessMaterial->GetParameterValue(EMaterialParameterType::Vector, parameterInfo, metadata);
	
	if (callResult) {
		return metadata.Value.AsLinearColor().LinearRGBToHSV();
	}

	return FLinearColor::White;
}

void SCyberGafferWindowContent::OnColorGradingValueChanged(FLinearColor color) {
	if (!IsPostProcessMaterialValid()) {
		return;
	}

	auto instanceConstant = Cast<UMaterialInstanceConstant>(_postProcessMaterial);
	FMaterialParameterInfo parameterInfo(TEXT("Multiplier"));
	if (instanceConstant) {
		instanceConstant->SetVectorParameterValueEditorOnly(parameterInfo, color.HSVToLinearRGB());
	}
}

void SCyberGafferWindowContent::OnColorGradingCaptureEnd() {
	SaveMaterialChanges(_postProcessMaterial);
}

FText SCyberGafferWindowContent::GetShadersIncludePath() const {
	if (!_settings) {
		return FText();
	}

	return _settings->ShadersIncludePath;
}

void SCyberGafferWindowContent::OnShadersIncludePathCommitted(const FText& newText, ETextCommit::Type commitType) {
	if (!_settings) {
		return;
	}
	
	if (newText.CompareTo(_settings->ShadersIncludePath) == 0) {
		return;
	}
	
	FString commitTypeStr;
	switch (commitType)
	{
	case ETextCommit::Default:
		{
			commitTypeStr = "Default";
			break;
		}
	case ETextCommit::OnCleared:
		{
			commitTypeStr = "OnCleared";
			break;
		}
	case ETextCommit::OnEnter:
		{
			commitTypeStr = "OnEnter";
			break;
		}
	case ETextCommit::OnUserMovedFocus:
		{
			commitTypeStr = "OnUserMovedFocus";
			break;
		}
	}
	
	UE_LOG(LogTemp, Log, TEXT("%s"), *commitTypeStr);

	if (!FPaths::DirectoryExists(newText.ToString())) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnShadersIncludePathCommitted: invalid path"));
		return;
	}

	const auto shadersDir = FModuleManager::Get().GetModuleChecked<FCyberGafferModule>("CyberGaffer").GetShaderDirectory();
	auto shadersIncludePath = FPaths::Combine(shadersDir, "Include");
	shadersIncludePath = shadersIncludePath.Replace(TEXT("/"), TEXT("\\"));
	if (FPaths::DirectoryExists(shadersIncludePath)) {
		const auto command = FString::Printf(TEXT("/c rd \"%s\""), *shadersIncludePath);
		auto result = FPlatformProcess::CreateProc(TEXT("cmd.exe"), *command, false, true, false, nullptr, 0, nullptr, nullptr, nullptr);

		while (FPlatformProcess::IsProcRunning(result)) {
			FPlatformProcess::Sleep(0.1f);
		}
	}

	if (FPaths::DirectoryExists(shadersIncludePath)) {
		UE_LOG(LogTemp, Error, TEXT("SCyberGafferWindowContent::OnShadersIncludePathCommitted: failed to delete junction"));
		return;
	}

	const auto command = FString::Printf(TEXT("/c mklink /j \"%s\" \"%s\""), *shadersIncludePath, *newText.ToString().Replace(TEXT("/"), TEXT("\\")));
	UE_LOG(LogTemp, Log, TEXT("%s"), *command);
	FPlatformProcess::CreateProc(TEXT("cmd.exe"), *command, false, true, false, nullptr, 0, nullptr, nullptr, nullptr);

	_settings->ShadersIncludePath = newText;
	_settings->SaveConfig();

	TArray<UMaterialInterface*> materials;
	if (_postProcessMaterial != nullptr) {
		materials.Add(_postProcessMaterial->GetMaterial());
		materials.Add(_postProcessMaterial.Get());

		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_postProcessMaterial->GetMaterial()->GetName()));
		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_postProcessMaterial->GetName()));
	}
	if (_cameraPostProcessMaterial != nullptr) {
		materials.Add(_cameraPostProcessMaterial->GetMaterial());
		materials.Add(_cameraPostProcessMaterial.Get());

		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_cameraPostProcessMaterial->GetMaterial()->GetName()));
		FLevelEditorActionCallbacks::ExecuteExecCommand(FString::Printf(TEXT("RECOMPILESHADERS MATERIAL %s"), *_cameraPostProcessMaterial->GetName()));
	}

	SaveMaterialsChanges(materials);
	
	// FLevelEditorActionCallbacks::ExecuteExecCommand(TEXT("RECOMPILESHADERS CHANGED"));
}


#undef LOCTEXT_NAMESPACE
