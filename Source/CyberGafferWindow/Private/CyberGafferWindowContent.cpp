// Fill out your copyright notice in the Description page of Project Settings.


#include "CyberGafferWindowContent.h"

#include "Widgets/Docking/SDockTab.h"
#include "Widgets/SBoxPanel.h"
#include "Widgets/Layout/SBorder.h"
#include "Widgets/Layout/SGridPanel.h"
#include "Widgets/Text/STextBlock.h"
#include "Widgets/Input/SNumericEntryBox.h"
#include "Layout/Margin.h"
#include "Styling/AppStyle.h"
#include "UObject/ConstructorHelpers.h"

// #include "DetailsViewArgs.h"
#include "IStructureDetailsView.h"
#include "Materials/MaterialInstanceConstant.h"
#include "Modules/ModuleManager.h"
#include "Widgets/Colors/SColorWheel.h"
// #include "PropertyEditorModule.h"
// #include "UObject/StructOnScope.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Editor/UnrealEd/Public/FileHelpers.h"

#define LOCTEXT_NAMESPACE "FCyberGafferWindowModule"

// CyberGafferWindowContent::CyberGafferWindowContent() { }
// CyberGafferWindowContent::~CyberGafferWindowContent() { }

void SCyberGafferWindowContent::Construct(const FArguments& args) {
	// Code for DetailView autogenerated UI
	// FStructureDetailsViewArgs structureDetailsViewArgs;
	// FDetailsViewArgs detailsViewArgs;
	// detailsViewArgs.bAllowSearch = false;

	// auto& propertyEditor = FModuleManager::Get().LoadModuleChecked<FPropertyEditorModule>(TEXT("PropertyEditor"));
	// _windowFields = MakeShared<FStructOnScope>(FCyberGafferWindowFields::StaticStruct());
	// _detailsView = propertyEditor.CreateStructureDetailView(detailsViewArgs, structureDetailsViewArgs, _windowFields);
	// _detailsView->GetOnFinishedChangingPropertiesDelegate().AddSP(this, &SCyberGafferWindowContent::OnPropertiesChanged);

	_settings = NewObject<UCyberGafferWindowSettings>();

	ReadCurrentSceneName();

	if (_currentSceneName.IsSet()) {
		auto sceneSettings = _settings->ScenesSettings.Find(_currentSceneName.GetValue());
		if (sceneSettings) {
			_postProcessMaterial = LoadMaterialUsingPath(sceneSettings->PostProcessMaterial);
			_cameraPostProcessMaterial = LoadMaterialUsingPath(sceneSettings->CameraPostProcessMaterial);
		} else {
			_settings->ScenesSettings.Add(_currentSceneName.GetValue(), FCyberGafferWindowSceneSettings());
			_settings->SaveConfig();
		}
	}

	UMaterialParameterCollection* collection = Cast<UMaterialParameterCollection>(StaticLoadObject(UMaterialParameterCollection::StaticClass(), nullptr, TEXT("/Script/Engine.MaterialParameterCollection'/CyberGaffer/Materials/CyberGafferPostProcessParameters.CyberGafferPostProcessParameters'")));
	if (collection == nullptr) {
		UE_LOG(LogTemp, Error, TEXT("Failed to find material parameters"));
	}
	
	_postProcessMaterialSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetPostProcessMaterialPath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(UMaterialInstance::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged));
	
	_cameraPostProcessMaterialSelector = SNew(SObjectPropertyEntryBox)
		.ObjectPath(this, &SCyberGafferWindowContent::GetCameraPostProcessMaterialPath)
		.DisplayBrowse(true)
		.DisplayThumbnail(true)
		.AllowedClass(UMaterialInstance::StaticClass())
		.EnableContentPicker(true)
		.OnObjectChanged(FOnSetObject::CreateSP(this, &SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged));

	auto separator = SNew(SSeparator).Orientation(Orient_Vertical);

	const float headerWidth = 0.4f;
	const float valueWidth = 0.6f;

	const FMargin headerMargin = FMargin(5, 0, 10, 0);
	const FMargin valueMargin = FMargin(10, 0, 5, 0);
	
	ChildSlot [
		// Code for DetailView autogenerated UI
		// _detailsView->GetWidget().ToSharedRef()
		
		SNew(SVerticalBox)
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("PostProcessMaterialText", "Post Process Material"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				_postProcessMaterialSelector.ToSharedRef()
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("PostProcessMaterialText", "Camera Post Process Material"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				_cameraPostProcessMaterialSelector.ToSharedRef()
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SSeparator)
			.Orientation(Orient_Horizontal)
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("ExposureCompensationText", "ExposureCompensation"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				SNew(SNumericEntryBox<float>)
				.Font(FAppStyle::GetFontStyle(TEXT("MenuItem.Font")))
				.AllowSpin(true)
				.MinValue(TOptional<float>())
				.MaxValue(TOptional<float>())
				.MinSliderValue(-10.0)
				.MaxSliderValue(10.0)
				.Delta(0.01f)
				.LinearDeltaSensitivity(0.001f)
				.Value(this, &SCyberGafferWindowContent::GetExposureCompensation)
				.OnValueChanged(this, &SCyberGafferWindowContent::OnExposureCompensationValueChanged)
				.OnValueCommitted(this, &SCyberGafferWindowContent::OnExposureCompensationValueCommited)
				.ToolTipText(LOCTEXT("ExposureCompensationText", "Exposure Compensation"))
				.IsEnabled(this, &SCyberGafferWindowContent::IsPostProcessMaterialValid)
			]
		]
		+SVerticalBox::Slot()
		.AutoHeight()
		.Padding(0)
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.FillWidth(headerWidth)
			.HAlign(HAlign_Left)
			.Padding(headerMargin)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("ColorGradingText", "Color Grading"))
			]
			+SHorizontalBox::Slot()
			.AutoWidth()
			[
				separator
			]
			+SHorizontalBox::Slot()
			.FillWidth(valueWidth)
			.HAlign(HAlign_Right)
			.Padding(valueMargin)
			[
				SNew(SColorWheel)
				.SelectedColor(this, &SCyberGafferWindowContent::GetColorGradingColor)
				.OnValueChanged(this, &SCyberGafferWindowContent::OnColorGradingValueChanged)
				.OnMouseCaptureEnd(this, &SCyberGafferWindowContent::OnColorGradingCaptureEnd)
				.ToolTipText(LOCTEXT("ExposureCompensationText", "Exposure Compensation"))
				.IsEnabled(this, &SCyberGafferWindowContent::IsPostProcessMaterialValid)
			]
		]
	];
}

// void SCyberGafferWindowContent::OnPropertiesChanged(const FPropertyChangedEvent& propertyChangedEvent) {
// 	const auto name = propertyChangedEvent.GetMemberPropertyName();
// 	UE_LOG(LogTemp, Log, TEXT("%s"), *name.ToString());
// }

UMaterialInstance* SCyberGafferWindowContent::LoadMaterialUsingPath(const FString& path) {
	if (path.IsEmpty()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::LoadMaterialUsingPath: path is empty"));
		return nullptr;
	}
	
	auto& module = FModuleManager::GetModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry"));
	FAssetData assetData;
	FSoftObjectPath objectPath(path);
	if (module.Get().TryGetAssetByObjectPath(objectPath, assetData) == UE::AssetRegistry::EExists::Exists) {
		return Cast<UMaterialInstance>(assetData.GetAsset());
	}
	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::LoadMaterialUsingPath: failed to load asset at path %s"), *path);
	return nullptr;
}

FString SCyberGafferWindowContent::GetPostProcessMaterialPath() const {
	// auto currentSceneName = GetCurrentSceneName();
	// if (!currentSceneName.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetPostProcessMaterialPath: current scene name is null"));
	// 	return FString();
	// }
	//
	// auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	// if (!sceneSettings.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetPostProcessMaterialPath: current scene settings is null"));
	// 	return FString();
	// }
	//
	// auto postProcessMaterial = sceneSettings.GetValue().PostProcessMaterial;
	//
	// if (postProcessMaterial != nullptr) {
	// 	return postProcessMaterial->GetPathName();
	// }

	if (_postProcessMaterial.IsValid()) {
		return _postProcessMaterial->GetPathName();
	}

	return FString();
}

void SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged(const FAssetData& assetData) {
	auto currentSceneName = GetCurrentSceneName();
	if (!currentSceneName.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged: current scene name is null"));
		return;
	}
	
	auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	if (!sceneSettings.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnPostProcessMaterialSelectorValueChanged: current scene settings is null"));
		return;
	}
	
	UMaterialInstance* materialInstance = Cast<UMaterialInstance>(assetData.GetAsset());
	if (materialInstance) {
		// _postProcessMaterial = MakeWeakObjectPtr<UMaterialInstance>(materialInstance);
		auto materialPath = materialInstance->GetPathName();
		sceneSettings.GetValue()->PostProcessMaterial = materialPath;
	} else {
		// _postProcessMaterial = nullptr;
		sceneSettings.GetValue()->PostProcessMaterial = "";
	}
	_settings->SaveConfig();
	
	_postProcessMaterial = materialInstance;
}

FString SCyberGafferWindowContent::GetCameraPostProcessMaterialPath() const {
	// auto currentSceneName = GetCurrentSceneName();
	// if (!currentSceneName.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetCameraPostProcessMaterialPath: current scene name is null"));
	// 	return FString();
	// }
	//
	// auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	// if (!sceneSettings.IsSet()) {
	// 	UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::GetCameraPostProcessMaterialPath: current scene settings is null"));
	// 	return FString();
	// }
	//
	// auto cameraPostProcessMaterial = sceneSettings.GetValue().CameraPostProcessMaterial;
	//
	// if (cameraPostProcessMaterial != nullptr) {
	// 	return cameraPostProcessMaterial->GetPathName();
	// }

	if (_cameraPostProcessMaterial.IsValid()) {
		return _cameraPostProcessMaterial->GetPathName();
	}

	return FString();
}

void SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged(const FAssetData& assetData) {
	auto currentSceneName = GetCurrentSceneName();
	if (!currentSceneName.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged: current scene name is null"));
		return;
	}
	
	auto sceneSettings = _settings->GetSettingsForScene(currentSceneName.GetValue());
	if (!sceneSettings.IsSet()) {
		UE_LOG(LogTemp, Log, TEXT("SCyberGafferWindowContent::OnCameraPostProcessMaterialSelectorValueChanged: current scene settings is null"));
		return;
	}
	
	UMaterialInstance* materialInstance = Cast<UMaterialInstance>(assetData.GetAsset());
	if (materialInstance) {
		// _cameraPostProcessMaterial = MakeWeakObjectPtr<UMaterialInstance>(materialInstance);
		sceneSettings.GetValue()->CameraPostProcessMaterial = materialInstance->GetPathName();
	} else {
		// _cameraPostProcessMaterial = nullptr;
		sceneSettings.GetValue()->CameraPostProcessMaterial = "";
	}
	_settings->SaveConfig();
	
	_cameraPostProcessMaterial = materialInstance;
}

TOptional<float> SCyberGafferWindowContent::GetExposureCompensation() const {
	if (!IsPostProcessMaterialValid()) {
		return 0.0f;
	}
	FMemoryImageMaterialParameterInfo parameterInfo(TEXT("Expose Compensation"));
	FMaterialParameterMetadata metadata;
	const auto callResult = _postProcessMaterial->GetParameterValue(EMaterialParameterType::Scalar, parameterInfo, metadata);
	
	if (callResult) {
		return metadata.Value.AsScalar();
	}

	return 0.0f;
}

void SCyberGafferWindowContent::OnExposureCompensationValueChanged(float value) {
	if (!IsPostProcessMaterialValid()) {
		return;
	}

	auto instanceConstant = Cast<UMaterialInstanceConstant>(_postProcessMaterial);
	FMaterialParameterInfo parameterInfo(TEXT("Expose Compensation"));
	if (instanceConstant) {
		instanceConstant->SetScalarParameterValueEditorOnly(parameterInfo, value);
	}
}

void SCyberGafferWindowContent::OnExposureCompensationValueCommited(const float newValue, ETextCommit::Type commitType) {
	OnExposureCompensationValueChanged(newValue);

	SaveMaterialChanges(_postProcessMaterial);
}

TOptional<FString> SCyberGafferWindowContent::ReadCurrentSceneName() {
	auto world = GEditor->GetEditorWorldContext().World();
	if (!world) {
		return TOptional<FString>();
	}
	
	auto sceneName = world->GetMapName();
	if (sceneName.IsEmpty()) {
		return TOptional<FString>();
	}

	auto sceneBaseName = FPaths::GetBaseFilename(sceneName);
	SetCurrentSceneName(sceneName);
	
	return sceneBaseName;
}

TOptional<FString> SCyberGafferWindowContent::GetCurrentSceneName() const {
	FScopeLock lock(&_currentSceneNameCriticalSection);
	return _currentSceneName;
}

void SCyberGafferWindowContent::SetCurrentSceneName(const FString& newSceneName) {
	FScopeLock lock(&_currentSceneNameCriticalSection);
	if (newSceneName.IsEmpty()) {
		_currentSceneName.Reset();
	} else {
		_currentSceneName = newSceneName;
	}
}

void SCyberGafferWindowContent::SaveMaterialChanges(TWeakObjectPtr<UMaterialInstance> material) {
	material->PostEditChange();
	material->MarkPackageDirty();

	TArray<UPackage*> packagesToSave;
	packagesToSave.Add(material->GetOutermost());

	FEditorFileUtils::PromptForCheckoutAndSave(packagesToSave, true, /*bPromptToSave=*/ false);
}

bool SCyberGafferWindowContent::IsPostProcessMaterialValid() const {
	return _postProcessMaterial.IsValid();
}

FLinearColor SCyberGafferWindowContent::GetColorGradingColor() const {
	if (!IsPostProcessMaterialValid()) {
		return FLinearColor::White;
	}

	FMemoryImageMaterialParameterInfo parameterInfo(TEXT("Multiplier"));
	FMaterialParameterMetadata metadata;
	const auto callResult = _postProcessMaterial->GetParameterValue(EMaterialParameterType::Vector, parameterInfo, metadata);
	
	if (callResult) {
		return metadata.Value.AsLinearColor().LinearRGBToHSV();
	}

	return FLinearColor::White;
}

void SCyberGafferWindowContent::OnColorGradingValueChanged(FLinearColor color) {
	if (!IsPostProcessMaterialValid()) {
		return;
	}

	auto instanceConstant = Cast<UMaterialInstanceConstant>(_postProcessMaterial);
	FMaterialParameterInfo parameterInfo(TEXT("Multiplier"));
	if (instanceConstant) {
		instanceConstant->SetVectorParameterValueEditorOnly(parameterInfo, color.HSVToLinearRGB());
	}
}

void SCyberGafferWindowContent::OnColorGradingCaptureEnd() {
	SaveMaterialChanges(_postProcessMaterial);
}


#undef LOCTEXT_NAMESPACE
